---
tags:
  - Unity
  - Shader
date: 2025-02-23
---

> [!info] 머리말
> "The Unity Shaders Bible." 이라는 책을 읽고 정리한 내용이다.

---
##  I. 폴리곤 객체의 속성
*Properties of a **polygonal** object*
**폴리곤**은 선분으로 둘러쌓인 닫힌 평면 도형이다.
어원부터가 그리스어 *πολύγωνος*에서 유래됐다고 한다. (*Poly(많은) + Gnow(각도)  = Polygon*)

![[Pasted image 20250223232155.png]]

**기본 타입(Primitive)** 은 폴리곤으로 구성된 **3차원 지오메트릭 객체**이다.
유니티(블렌더, 마야 등)에서 자주 볼 수 있는 **구(Spheres)**, **상자(Boxes)**, **사각형(Quads)**, **원기둥(Cylinders)**, **원통(Capsules)** 등이 바로 기본 타입이다.

이 객체들은 생김새는 전부 다르지만, 공통적인 속성이 있다.
- **정점(Vertices)**: 객체의 모양을 형성하는 점들
- **접선(Tangents)**: 표면의 방향을 나타내는 벡터
- **법선(Normals)**: 표면과 수직 방향을 나타내는 벡터
- **UV 좌표(UV coordinates)**: 3d 객체에 텍스쳐를 입히기 위한 2D 좌표
- **색상(Color)**: 객체의 색상 정보

> [!TIP] 위 데이터는 **메쉬(Mesh)** 라는 데이터 타입 내에 저장된다.
> 그러므로, 셰이더를 통해 이 속성들에 접근하여 객체의 모양이나 색을 자유롭게 변경할 수 있다.
> 예를 들어, 모델링 툴을 통해 정점 위치를 조정하여 객체를 변형시킬 수 있다.

![[Pasted image 20250223233400.png]]

---
### i. 정점
*Vertices*
정점은 2d나 3d 공간에서 객체의 표면을 정의할 수 있는 "**점(Point)**"의 집합이다.
즉, 객체의 모양을 만드는 가장 기초 단위이다.

정점에는 두 가지 중요한 특징이 있다:
- **Transform 컴포넌트의 자식이다.**
- **부피(Volume)** 중심에 따라 정의된 "위치"
> [!TIP] 정점은 객체 전체의 부피를 기준으로 위치가 정의된다!

Transform 노드는 객체의 **중심점(Pivot)** 에 따라 *위치(position)*, *회전(rotation)*, *크기(scale)* 를 설정하고, 그 아래 붙은 Shape 노드에는 정점의 위치와 같은, **지오메트리 속성(Geometry Attribute)** 이 들어있다.

따라서 Transform을 통해 객체의 **정점 집합(Vertex Set)** 을 이동, 회전 및 크기를 조정할 수 있다.
여기서 HLSL(셰이더)의 `POSITION[n]`시맨틱을 통해 정점의 위치(*부피와 관련된*) 정보를 가져올 수 있다.

> [!TIP] 시맨틱이란?
> **Semantic**: 해당 코드가 어떤 의미를 지니고, 전체 프로그램 중 어떤 역할을 하는가를 나타내는 것.
> 여기서 관점은 프로그램이 아닌, "**해당 코드**"이다. 예를 들어, `POSITION`은 정점의 위치를 의미한다.
> 즉,`foo(100)` -> `GetDamaged(100)` 이런 식으로 적어야 "시맨틱"하게 작성했다~ 라 할 수 있다.

![[Pasted image 20250224001757.png]]

---
### ii. 법선
*Normal*
**법선(Nomal)** 은 폴리곤 표면의 수직 벡터이다. 
대체로, 표면이 어느 방향을 향하고 있는지 나타내는 화살표로 법선은 표현된다.
이는 **면(Face)** 또는 **정점(Vertex)** 의 방향을 결정하는데 사용된다.

> [!TIP] 표면의 방향을 왜 알아야 할까?
> 3d 모델링 툴을 보면, 법선을 가시적으로 볼 수 있게끔 하는 옵션이 있다.
> 모델러는 법선을 통해 해당 표면이 제대로 된 방향을 보고 있는지 여부를 파악할 수 있다.
> 만약 법선이 안쪽을 향하고 있다면... 객체는 뒤집혀 보이게 된다.

![[Pasted image 20250224010555.png]]

---
### iii. 접선
*Tangent*
**접선(Tangent)** 은 3d 객체 표면의 UV 좌표 중, `U`방향(가로 방향)을 따르는 정규화된 벡터이다.
(UV좌표에 대해 미리 설명하자면, 텍스쳐를 입힐 때 사용하는 2d 좌표이다. 접선은 그 중 가로 방향을 나타내는 것이다.)

접선은 법선과 함께, 표면의 방향을 나타내는 데 사용된다. 법선이 수직 방향을 가리킨다면, 접선은 가로 방향을 가리킨다. 

![[Pasted image 20250224220012.png]]
- **빨강**: Tangent (접선)
- **파랑**: Normal (법선)
- **초록**: Binormal (종법선)

> [!WARNING] Binormal은 셰이더를 통해 지원되지 않는다.
> 그러므로, Normal과 Tangent를 통해 계산해야 한다.

---
### iv. UV 좌표
*UV Coordinates*
**UV 좌표**는 3d 객체에 2d 텍스쳐를 입히기 위해 존재하는 좌표이다.
쉽게 설명하자면, 3d 모델링을 2d 공간에 펼쳐서, 텍스쳐를 붙이는 작업을 할 수 있는 공간이다.
여기서, UV 좌표는 텍스쳐 맵 위에서 메쉬의 각 정점에 해당하는 **텍셀(Texel)** 을 제어하는 기준점 역할을 한다. 

> [!TIP] 텍셀이란?
> 말 그대로 블렌더의 UV 편집기를 누르면, 3d 모델이 펼쳐진다.
> 거기서 각 기준점 역할을 하는 정점이 있다. 이를 **텍셀(Texel)** 이라 부른다.

여기서 UV 좌표 위에 정점을 배치하는 작업을 **UV 매핑**이라 한다.
- 객체 메쉬를 2차원 공간에 펼치는 작업
- 펼친 메쉬를 텍스쳐 위에 올려, 편집 및 구성

셰이더에서는 UV 좌표를 텍스쳐를 입히거나, 단순히 정보만을 저장하는 데 활용할 수 있다.

![[Pasted image 20250224222501.png]]

> [!TIP] 우측이 바로 UV 좌표이다. 여기서 가로축이 `U`, 세로축이 `V`를 의미한다.

UV 좌표는 `0.0f ~ 1.0f` 사이의 범위를 갖는다.
`0.0f`는 시작점을 의미하고, `1.0f`는 끝점을 의미한다.

![[Pasted image 20250224222820.png]]

---
### v. 버텍스 컬러
*Vertex Color*
**버텍스 컬러**는 정점에 저장된 색상 정보이다.
기본 값은 흰색 (RGBA 채널 값 모두 `1.0f`)이지만, 조명 및 다른 색상과 계산되기 때문에 최종 색상은 달라질 수 있다.

버텍스 컬러를 사용하면, 정점 단위로 색상을 조절할 수 있다.
이를 통해 그라데이션과 같은 효과를 만들 수도 있다!

![[Pasted image 20250224223132.png]]

---
## II. 렌더 파이프라인 아키텍쳐
*Render Pipeline Architecture*
유니티에는 세 가지 렌더 파이프라인이 있다.
1. **Built-in RP**: 기본 렌더 파이프라인
2. **Universal RP**: 범용적인 작업에 용이하다. (옛 이름은 **Lightweight RP**)
3. **High-Definition RP**: 고품질 그래픽 작업용

> [!INFO] 파이프라인이란?
> **파이프라인**은 하나의 거대한 작업을 수행하기까지의 과정을 의미한다.

> [!TIP] 그렇다면.. 렌더 파이프라인이란?
> **렌더 파이프라인**은 3d 객체가 컴퓨터 화면에 그려질 때 까지의 전체 과정을 의미한다.

![[Pasted image 20250224223832.png]]

각 파이프라인은 고유한 특성이 있다.
어떤 파이프 라인을 사용하느냐에 따라 재질(Material), 조명(Light), 텍스쳐(Texture) 등의 셰이더 동작이 달라진다.
즉, 파이프라인 작업 하나로 인해, 객체의 모습과 성능이 완전히 바뀔 수 있다는 뜻이다.

일반적으로 실시간 렌더링 엔진들의 렌더 파이프라인은 다음 4가지 단계를 거친다.
1. **애플리케이션 단계(Application Stage)**
2. **지오메트리 처리 단계(Geometry Procesisng Phase)**
3. **레스터화 단계(Rasterization Stage)**
4. **픽셀 처리 단계(Pixel Processing Stage)**

![[Pasted image 20250224225008.png]]

---
### i. 애플리케이션 단계
*Application Stage*
**애플리케이션 단계**는 **CPU**에서 시작된다. 여기서는 씬에서 발생하는 대부분의 작업을 처리한다.
- 충돌 감지(Collision Detection)
- 텍스처 애니메이션(Texture Animation)
- 키보드 및 마우스 입력 처리
또한, 메모리에 저장된 데이터를 읽어와 기본 타입(Primitive)로 변환한다.
이 단계가 끝나면, 데이터는 "지오메트리 처리 단계"로 넘어가서, 행렬 연산을 통해 정점의 위치 변환이 일어난다! (Transform 변수가 만들어진다는 뜻이다.)

![[Pasted image 20250224230005.png]]

---
### ii. 지오메트리 처리 단계
*Geometry processing phase*
컴퓨터 화면에 보이는 이미지는 GPU가 CPU의 요청을 받아 만드는 것이다.
GPU가 CPU의 요청을 받아 이미지를 그리는 과정은 크게 두 단계로 나눌 수 있다:
1. 렌더링 상태 설정(Configuration)
2. 화면에 객체 그리기

> [!TIP] 렌더링 상태 설정
> 지오메트리 처리부터 픽셀 처리까지의 계획을 이 때 세운다.

그 중, 지오메트리 처리 단계는 GPU에서 시작되어 객체의 정점을 처리하는 단계이다. 다음 네 가지 과정을 거친다:
1. **정점 셰이딩(Vertex Shading)**: 정점 위치 계산
2. **투영(Projection)**: 3d를 2d로 투사
3. **클리핑(Clipping)**: 씬(시야?) 밖의 객체 제거
4. **화면 매핑(Screen Mapping)**: 2d 스크린 좌표 변환

![[Pasted image 20250224231836.png]]

#### 01. 정점 셰이딩
*Vertex Shading*
이전 단계인 애플리케이션 단계에서 만들어진 기본 타입(대부분 삼각형을 사용한다!)을 갖고 정점 셰이딩을 시작한다. 이 과정은 **정점 셰이더 단계(Vertex Shader Stage)** 라고도 부른다.
정점 셰이딩은 이렇게 진행된다:
1. 객체의 정점 위치를 계산한다.
2. 화면에 투사할 수 있도록, 좌표계를 변환한다.
이 때, `Normal`, `Tangent`, `UV Coord` 같은 속성도 다음 단계로 전달할 수 있다!

#### 02-03. 투영 및 클리핑
*Projection, Clipping*
이 과정은 카메라 설정이 원근인지, 직교인지에 따라 달라진다.
여기서 렌더링은 카메라의 시야(Frustum) 내에서만 발생한다고 이해하면 된다!
여기서 카메라의 시야를 **뷰 공간(View Space)** 라고 한다.

카메라 시야 밖에 있거나, 걸쳐 있는 객체는 **클리핑**되어 잘려나가고, 렌더링에서 제외된다.

#### 04. 화면 매핑
*Screen Mapping*
클리핑 과정을 통과한 객체는 메모리에 저장되고, **화면 매핑**을 통해 3d 좌표가 2d 화면 좌표로 변환된다.
다시 말해, 이 단계를 거쳐 3d 객체가 2d로는 어떻게 보일지 결정된다.

![[Pasted image 20250225231344.png]]

---
### iii. 래스터화 단계
*Rasterization stage*
지오메트리 처리 단계를 거친 객체는 2d 좌표를 가지게 된다.
이제 이 객체가 화면의 어떤 픽셀에 나타날 지를 찾아야 한다. 이 과정을 바로 **래스터화**라 한다.

래스터화 단계는 다음 두 단계로 진행된다:
1. **삼각형 설정(Triangle Setup)**: 삼각형의 경계(Edge)를 정의하는 데이터 구성
2. **삼각형 탐색(Triangle Traversal)**: 경계 안의 픽셀을 찾아낸다.

#### 01. 삼각형 설정
*Triangle Setup*
삼각형 경계(윤곽선?, `Edge`)에 대한 방정식을 통해, 데이터를 수집한다.
이 데이터를 바탕으로 어떤 픽셀이 어떤 삼각형과 매핑되는 지를 찾을 수 있다.

#### 02. 삼각형 탐색
*Triangle Traversal*
위 삼각형 설정 단계에서 수집한 데이터를 바탕으로, 해당 삼각형 내에 있는 픽셀을 찾아 `Fragments`라는 이름의 그룹으로 묶는다.

여기서 `Fragments`는 색을 입힐 `Pixel`들의 모음이다. 이 `Fragments`는 다음 단계에서 색이나 질감을 입히는 데 사용한다.

![[Pasted image 20250225233857.png]]

---
### iv. 픽셀 처리 단계
*Pixel processing stage*
이전 프로세스에서 보간된 값을 사용하여, 모든 픽셀이 화면에 투사될 준비가 되면 이 마지막 단계가 시작된다.
이 때 픽셀 셰이더 단계라고도 부르는 프래그먼트 셰이더 단계가 시작되며, 각 픽셀의 가시성을 담당한다.
이 단계는 픽셀의 최종 색상을 처리한 다음, 색상 버퍼로 전송한다.

![[Pasted image 20250301143727.png]]

3d 객체가 덮는 영역은 화면에서 픽셀로 변환된다.

---
## III. 렌더 파이프라인의 종류
*Types of Render Pipeline*
기본적으로 유니티에 포함된 가장 오래된 Built-in RP(소프트웨어 속한 가장 오래된 엔진)가 있다.
그리고, Universal RP와 High-Definition RP는 더 나은 그래픽 성능을 위해 사전 최적화되어 있는 최신의 Scriptable RP라는 렌더 파이프라인 유형이 있다.
Unity에서 새 프로젝트를 생성할 때 보면, 이 세가지 렌더링 엔진 중 하나를 선택할 수 있다.

렌더 파이프라인에 관계 없이, 화면에 이미지를 생성하기 위해선 파이프라인을 통과해야 한다.
파이프라인에는 "**렌더 경로(Render Path)**"라는 이름의 다양한 처리 경로가 있다.

렌더 경로는 객체 조명 및 셰이딩과 관련된 일련의 작업에 해당한다.
이를 조명이 있는 씬 (Directional Light와 Sphere가 있는 씬을 상상해보자)을 그래픽으로 처리할 수 있다.

렌더 경로는 대체로 다음과 같다:
1. Forward Rendering
2. Deferred Shading
3. Legacy deferred
4. Legacy vertex lit

이들은 각각 기능 및 성능 특성이 다르다.

유니티에서는 기본 렌더 경로가 포워드 렌더링이다. 이는 유니티에 포함된 세 가지 유형의 렌더 파이프라인(Built-in, Universal, High-Definition)의 기본 경로이다.
이는 그래픽카드 호환성이 높고, 조명 계산에 제한을 둬서, 프로세스를 가장 최적화한 타입니다.

씬에 객체와 Direct 조명이 있다고 상상해보자. 이 둘 사이의 상호작용은 다음 두 가지 기본 개념을 기반으로 한다:
1. 조명의 특성
2. 객체 머테리얼의 특성

이러한 상호 작용을 조명 모델(Lighting Model)이라고 한다. 기본 조명 모델은 세 가지 속서으이 합에 해당한다.
- **주변 색상(Ambient Color)**
- **확산 반사(Diffuse Reflection)**
- **정반사(Specular reflection)**

조명 계산은 셰이더 내에서 수행되며, 정점 및 프래그먼트 별로 수행될 수 있다.
조명이 정점 별로 계산되는 경우를 "정점 별 조명"이라 하고, 이는 "정점 셰이더 단계"에서 수행된다.
마찬가지로, 프래그먼트 별로 계산되는 경우를 "프래그먼트 별 조명"이라 하고, "프래그먼트 셰이더 단계"에서 수행된다.

---
### i. 포워드 렌더링
*Forward Rendering*
`Forward`는 기본 렌더 경로이다. 노멀맵, 개별 픽셀 조명, 그림자 등 머테리얼의 모든 일반적인 기능을 지원한다. 이 렌더 경로는 셰이더에서 사용할 수 있는 두 가지 코드 작성 pass가 있다. (pass가 뭐지..)

하나는 `base pass`이고, 또 하나는 `additional pass`이다:
- `base pass`에서는 `ForwardBase Light Mode`를 정의한다.
- `additional pass`는 추가적인 조명 계산을 위한 `ForwardAdd Light Mode`를 정의한다.
두 pass 모두 조명 계산이 있는 셰이더만의 특징적인 함수이다.

#### 01. base pass
base pass는 픽세레 단위로 Directional 조명을 처리할 수 있으며, 씬에 Directional Light가 여러 개 있는 경우에는 가장 밝은 조명에 우선 순위를 둔다.
또한 base pass는 `Light Probe`, `Global Illumination`, 그리고 `Ambient Illumination (Sky light)`를 처리할 수 있다.

#### 02. additional pass
additional pass는 객체에 영향을 주는 `point light`, `spot light`, `area light` 또는 `shadow`를 처리할 수 있다.
base pass 때, 씬에 조명이 두 개 있는 경우, 객체는 그 중 하나의 조명에만 영향을 받는다고 했다.
그러나, additional pass를 기준으로 정의한 경우, 객체는 여러 조명 모두에 영향을 받을 수 있게 된다.

#### 03. 드로우 콜
*Draw call*
한 가지 고려해야 할 점은, 각 `illuminated pass`가 독립적인 `Draw call`을 생성한다는 점이다.
정의상, 드로우 콜은 컴퓨터 화면에 요소가 그려질 때마다 GPU에서 생성되는 `Call Graphic`이다.
이러한 호출은 많은 양의 계산이 필요한 프로세스이므로, 가능한 한 최소한으로 유지해야 한다. (특히 모바일 기기의 경우에는 매우 중요하다)

이 개념을 이해하기 위해, 씬에 네 개의 구체와 하나의 Directional 조명이 있다고 가정해보자.
각 구체는 본질적으로 GPU에 대한 콜을 생성한다. 즉, 각 구체는 모두 독립적으로 드로우 콜을 생성한다.

마찬가지로, Directional 조명은 씬에 있는 모든 구체에 영향을 미친다. 이는 각 구체에 대해 추가적인 드로우 콜을 생성한다.

대부분의 경우, 그림자 투영을 계산하기 위해, 셰이더에는 additional pass가 포함되어 있기 때문에, 4개의 구체와 Directional 조명은 총 8개의 그래픽 콜을 생성한다.

`base pass`를 결정한 후, 셰이더에 다른 `pass`를 추가하면 각 객체에 대한 드로우 콜이 추가되어, 결과적으로 그래픽 부하가 각각에 대해서 증가하게 된다.

---
### ii. 디퍼드 셰이딩
*Deferred Shading*
이 렌더 경로는 3d 객체와 조명을 분리하여, 씬의 각 광원을 계산하는 `lighting pass`가 단 하나만 존재함을 보장하며, 해당 광원의 영향을 받는 픽셀에 대해서만 계산되도록 한다.
이는 여러 객체에 영향을 미치는 상당한 양의 빛을 생성할 수 있어 최종 렌더링의 충실도를 향상시키지만, 명목상 GPU의 픽셀 당 계산을 증가시킨다. (유리한 측면...? 그런 뜻으로 적은 건가)

디퍼드 셰이딩은 여러 광원을 계산하는 데 있어 포워드보다 우수하지만, 몇 가지 제한 사항이 있다.
여러 렌더 타겟이 있어야 하고, Shader Model 3.0 이상을 지원해야 하고, Depth render texture를 지원하는 그래픽카드가 필요하다.
모바일 기기의 경우, OpenGL ES 3.0 이상을 지원하는 디바이스에서만 작동한다.
또한 원근(Perspective) 카메라가 있는 프로젝트에서만 사용할 수 있다. 디퍼드 셰이딩은 Orthographic 투영은 지원하지 않는다.

---
### iii. 어떤 렌더 파이프라인을 고를지
예전엔 Built-in RP만 있었기에, 2d 또는 3d 프로젝트를 시작하는 것이 매우 쉬웠다.
지금은 다음과 같은 요소를 고려해야 한다:
1. PC는 모바일 기기나 콘솔보다 컴퓨팅 성능이 뛰어나다. 만약 비디오 게임이 하이엔드 기기를 대상으로 하는 경우에는 High-Definition 및 Built-in RP를 사용할 수 있다.
2. 만약 비디오 게임을 중간 해상도 정도의 그래픽으로 제작하려는 경우, Universal RP나 Built-in RP를 사용할 수 있다.
어떻게 두 경우 모두에 Built-in RP를 사용할 수 있을까?

요즘의 Built-in RP는 훨씬 더 유연하기 때문에, 더 기술적인 작업이 가능하다. 또한 사전 최적화가 필요하지 않다. High-Definition RP는 고사양 그래픽을 생성하도록 사전 최적화가 되어 있고, Universal RP는 중간급 그래픽을 생성하도록 사전 최적화가 되어 있다.

렌더 파이프라인을 선택할 때 중요한 요소는 바로 셰이더이다. 일반적으로 High-Definition 및 Universal RP 모두 **셰이더 그래프**를 통해 생성된다.

셰이더 그래프 방식의 긍정적인 측면은 HLSL로 코드를 작성할 필요 없고, 노드를 통해 시각적으로 셰이더를 제작할 수 있다는 점이 있다.
대신 제작 중, 유니티 버전을 올리려는 경우 셰이더 그래프의 내용이 크게 바뀌어 컴파일이 중단될 가능성이 매우 높다.

유니티에서 셰이더를 생성하는 가장 좋은 방법은 HLSL을 사용하는 것이다.
이렇게 하면, 프로그램이 다른 렌더 파이프라인에서 컴파일되고, 유니티 업데이트와 관계 없이 계속 작동할 수 있기 때문이다.
이 개념은 나중에 HLSL 파트에서 더 자세히 알아보도록 하자.

---
## IV. 행렬과 좌표 시스템
*Matrices and coordinate system*
셰이더를 만들 때 자주 등장하는 개념 중 하나는 행렬이다.
행렬은 특정 산술 규칙을 따르는 숫자 요소의 목록으로, 컴퓨터 그래픽스에서 자주 사용된다.

유니티에서 행렬은 공간 변환을 나타낸다. 종류는 다음과 같다:
- UNITY_MATRIX_MVP
- UNITY_MATRIX_MV
- UNITY_MATRIX_V
- UNITY_MATRIX_P
- UNITY_MATRIX_VP
- UNITY_MATRIX_T_MV
- UNITY_MATRIX_IT_MV
- unity_ObjectToWorld
- unity_WorldToObject
이들은 모두 4x4 행렬에 해당한다. (4개의 행과 4개의 열로 이루어진 숫자 값에 해당)

```C
UNITY_MATRIX
(
	Xx, Yx, Zx, Tx,
	Xy, Yy, Zy, Ty,
	Xz, Yz, Zz, Tz,
	Xt, Yt, Zt, Tw
);
```

"*I.i 정점*"에서 설명한 것처럼, 3d 객체에는 기본적으로 두 개의 노드가 있다.
Maya에서는 이를 Transform과 Shape라 하며, 둘 다 오브젝트의 중심 위치를 기준으로 정점으ㅢ 위치를 정의하는 **객체 공간(Object Space)** 에서 정점의 위치를 계산하는 역할을 담당한다.

객체의 각 정점의 최종 값에는 **모델 행렬(UNITY_MATRIX_M)** 이라는 행렬이 곱해지며, 이를 통해 `Transform`, `Rotation`, `Scale` 값을 수정할 수 있다.
이렇게 객체가 수정될 때마다 모델 행렬이 업데이트된다.

이 과정이 이루어지는 과정을 알아보자. 우선, 씬에 위치한 큐브를 변형해보자.
먼저 중심을 기준으로 (0.5x, -0.5y, -0.5z, 1.0w) 위치에 있는 큐브의 정점을 가져오자.

> [!TIP] W 채널의 의미
> `vectors`와 `points`를 균일하게 처리할 수 있는 `homogeneous`라는 좌표계에 해당한다.
> 행렬 변환에 있어 W 좌표는 0이나 1이다.
> 만약 W좌표가 **1이면, 공간의 한 점**을 나타내고, **0이라면 방향**을 나타낸다.

![[Pasted image 20250301164930.png]]
여기서 M은 Identity Matrix를 의미하고, 행렬 기본 값을 나타낸다.

행렬에 있어 고려해야 할 한 가지는, 첫 번째 행렬의 행 수가 두 번째 행렬의 열 수와 같을 때만 곱셈을 수행할 수 있다는 것이다. 이미 알려진 바와 같이, 이 모델 행렬은 4x4이고, 정점의 `position`은 4x1이다.

모델 행렬의 열 수는 정점 `position`의 행 수와 같다. 이 둘을 곱하면 4x1 모양의 새 행렬이 생긴다.
즉, 이렇게 새로운 정점 위치를 정의할 수 있게 된다. 이 곱셈 프로세스는 오브젝트의 모든 정점에 대해 발생하며, 이는 **정점 셰이더 단계(Vertex Shader Stage)** 에서 수행된다.

지금까지는 **객체 공간**에서 객체 본인이 중심이 된 정점 위치를 의미했다.
그렇다면, 월드 공간, 뷰 공간 또는 클립 공간은 무엇을 의미할까?

월드 공간은 월드의 중심에 따른 정점의 위치, 즉, 씬의 **그리드 시작점(0x, 0y, 0z, 1w)** 과 객체의 정점 위치 사이의 거리에 해당한다.

좌표를 객체 공간에서 월드 공간으로 변환하기 위해선, `unity_ObjectToWorld`를 사용하면 된다.

뷰 공간은 카메라 뷰를 기준으로, 객체의 정점 위치를 나타낸다.
월드 공간에서 뷰 공간으로 좌표를 변환하기 위해선, `UNITY_MATRIX_V` 행렬을 사용하면 된다.

![[Pasted image 20250301170013.png]]

마지막으로 투영 공간(Projection Space)라고도 부르는 클립 공간(Clip Space)은 카메라의 프러스텀에 대한 객체의 정점 위치를 나타낸다.
따라서 이 요소는 `Near Clipping Plane`, `Far Clipping Plane`, `Field of View`의 영향을 받는다.

좌표를 뷰 공간에서 클립 공간으로 변환하려면, `UNITY_MATRIX_P` 행렬을 사용하면 된다.

![[Pasted image 20250301170449.png]]

지금까지 서로 다른 공간 좌표에 대해 개념적인 수준에서 이야기했지만, 변환 행렬이 무엇을 가리키는지 명확하게 정의하진 않았다.

예를 들어, 내장 셰이더 변수 `UNITY_MATRIX_MVP`는 세 가지 다른 행렬의 곱셈을 나타낸다. `M`은 모델 매트릭스, `V`는 뷰 매트릭스, `P`는 투영 매트릭스를 나타낸다.
이 행렬은 주로 객체 정점을 객체 공간에서 클립 공간으로 변환하는데 사용된다.
3d 객체는 3d 환경에서 생성된 반면, 투사될 컴퓨터 화면은 2d이므로, 객체를 한 공간에서 다른 공간으로 꼭 변환해야 한다.

이 부분은 추후 정점 셰이더 스테이지의 `UnityObjectToClipPos(VRG)` 함수를 사용할 때 더 자세히 살펴볼 것이다.

---


