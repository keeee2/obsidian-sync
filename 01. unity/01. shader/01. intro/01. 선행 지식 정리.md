---
tags:
  - Unity
  - Shader
date: 2025-02-23
---

> [!info] 머리말
> "The Unity Shaders Bible." 이라는 책을 읽고 정리한 내용이다.

---
##  01. 폴리곤 객체의 속성
*Properties of a **polygonal** object*
**폴리곤**은 선분으로 둘러쌓인 닫힌 평면 도형이다.
어원부터가 그리스어 *πολύγωνος*에서 유래됐다고 한다. (*Poly(많은) + Gnow(각도)  = Polygon*)

![[Pasted image 20250223232155.png]]

**기본 타입(Primitive)** 은 폴리곤으로 구성된 **3차원 지오메트릭 객체**이다.
유니티(블렌더, 마야 등)에서 자주 볼 수 있는 **구(Spheres)**, **상자(Boxes)**, **사각형(Quads)**, **원기둥(Cylinders)**, **원통(Capsules)** 등이 바로 기본 타입이다.

이 객체들은 생김새는 전부 다르지만, 공통적인 속성이 있다.
- **정점(Vertices)**: 객체의 모양을 형성하는 점들
- **접선(Tangents)**: 표면의 방향을 나타내는 벡터
- **법선(Normals)**: 표면과 수직 방향을 나타내는 벡터
- **UV 좌표(UV coordinates)**: 3d 객체에 텍스쳐를 입히기 위한 2D 좌표
- **색상(Color)**: 객체의 색상 정보

> [!TIP] 위 데이터는 **메쉬(Mesh)** 라는 데이터 타입 내에 저장된다.
> 그러므로, 셰이더를 통해 이 속성들에 접근하여 객체의 모양이나 색을 자유롭게 변경할 수 있다.
> 예를 들어, 모델링 툴을 통해 정점 위치를 조정하여 객체를 변형시킬 수 있다.

![[Pasted image 20250223233400.png]]

---
## 02. 정점
*Vertices*
정점은 2d나 3d 공간에서 객체의 표면을 정의할 수 있는 "**점(Point)**"의 집합이다.
즉, 객체의 모양을 만드는 가장 기초 단위이다.

정점에는 두 가지 중요한 특징이 있다:
- **Transform 컴포넌트의 자식이다.**
- **부피(Volume)** 중심에 따라 정의된 "위치"
> [!TIP] 정점은 객체 전체의 부피를 기준으로 위치가 정의된다!

Transform 노드는 객체의 **중심점(Pivot)** 에 따라 *위치(position)*, *회전(rotation)*, *크기(scale)* 를 설정하고, 그 아래 붙은 Shape 노드에는 정점의 위치와 같은, **지오메트리 속성(Geometry Attribute)** 이 들어있다.

따라서 Transform을 통해 객체의 **정점 집합(Vertex Set)** 을 이동, 회전 및 크기를 조정할 수 있다.
여기서 HLSL(셰이더)의 `POSITION[n]`시맨틱을 통해 정점의 위치(*부피와 관련된*) 정보를 가져올 수 있다.

> [!TIP] 시맨틱이란?
> **Semantic**: 해당 코드가 어떤 의미를 지니고, 전체 프로그램 중 어떤 역할을 하는가를 나타내는 것.
> 여기서 관점은 프로그램이 아닌, "**해당 코드**"이다. 예를 들어, `POSITION`은 정점의 위치를 의미한다.
> 즉,`foo(100)` -> `GetDamaged(100)` 이런 식으로 적어야 "시맨틱"하게 작성했다~ 라 할 수 있다.

![[Pasted image 20250224001757.png]]

---
## 03. 법선
*Normal*
**법선(Nomal)** 은 폴리곤 표면의 수직 벡터이다. 
대체로, 표면이 어느 방향을 향하고 있는지 나타내는 화살표로 법선은 표현된다.
이는 **면(Face)** 또는 **정점(Vertex)** 의 방향을 결정하는데 사용된다.

> [!TIP] 표면의 방향을 왜 알아야 할까?
> 3d 모델링 툴을 보면, 법선을 가시적으로 볼 수 있게끔 하는 옵션이 있다.
> 모델러는 법선을 통해 해당 표면이 제대로 된 방향을 보고 있는지 여부를 파악할 수 있다.
> 만약 법선이 안쪽을 향하고 있다면... 객체는 뒤집혀 보이게 된다.

![[Pasted image 20250224010555.png]]

---
## 04. 접선
*Tangent*
**접선(Tangent)** 은 3d 객체 표면의 UV 좌표 중, `U`방향(가로 방향)을 따르는 정규화된 벡터이다.
(UV좌표에 대해 미리 설명하자면, 텍스쳐를 입힐 때 사용하는 2d 좌표이다. 접선은 그 중 가로 방향을 나타내는 것이다.)

접선은 법선과 함께, 표면의 방향을 나타내는 데 사용된다. 법선이 수직 방향을 가리킨다면, 접선은 가로 방향을 가리킨다. 

![[Pasted image 20250224220012.png]]
- **빨강**: Tangent (접선)
- **파랑**: Normal (법선)
- **초록**: Binormal (종법선)

> [!WARNING] Binormal은 셰이더를 통해 지원되지 않는다.
> 그러므로, Normal과 Tangent를 통해 계산해야 한다.

---
## 05. UV 좌표
*UV Coordinates*
**UV 좌표**는 3d 객체에 2d 텍스쳐를 입히기 위해 존재하는 좌표이다.
쉽게 설명하자면, 3d 모델링을 2d 공간에 펼쳐서, 텍스쳐를 붙이는 작업을 할 수 있는 공간이다.
여기서, UV 좌표는 텍스쳐 맵 위에서 메쉬의 각 정점에 해당하는 **텍셀(Texel)** 을 제어하는 기준점 역할을 한다. 

> [!TIP] 텍셀이란?
> 말 그대로 블렌더의 UV 편집기를 누르면, 3d 모델이 펼쳐진다.
> 거기서 각 기준점 역할을 하는 정점이 있다. 이를 **텍셀(Texel)** 이라 부른다.

여기서 UV 좌표 위에 정점을 배치하는 작업을 **UV 매핑**이라 한다.
- 객체 메쉬를 2차원 공간에 펼치는 작업
- 펼친 메쉬를 텍스쳐 위에 올려, 편집 및 구성

셰이더에서는 UV 좌표를 텍스쳐를 입히거나, 단순히 정보만을 저장하는 데 활용할 수 있다.

![[Pasted image 20250224222501.png]]

> [!TIP] 우측이 바로 UV 좌표이다. 여기서 가로축이 `U`, 세로축이 `V`를 의미한다.

UV 좌표는 `0.0f ~ 1.0f` 사이의 범위를 갖는다.
`0.0f`는 시작점을 의미하고, `1.0f`는 끝점을 의미한다.

![[Pasted image 20250224222820.png]]

---
## 06. 버텍스 컬러
*Vertex Color*
**버텍스 컬러**는 정점에 저장된 색상 정보이다.
기본 값은 흰색 (RGBA 채널 값 모두 `1.0f`)이지만, 조명 및 다른 색상과 계산되기 때문에 최종 색상은 달라질 수 있다.

버텍스 컬러를 사용하면, 정점 단위로 색상을 조절할 수 있다.
이를 통해 그라데이션과 같은 효과를 만들 수도 있다!

![[Pasted image 20250224223132.png]]

---
## 07. 렌더 파이프라인 아키텍쳐
*Render Pipeline Architecture*
유니티에는 세 가지 렌더 파이프라인이 있다.
1. **Built-in RP**: 기본 렌더 파이프라인
2. **Universal RP**: 범용적인 작업에 용이하다. (옛 이름은 **Lightweight RP**)
3. **High-Definition RP**: 고품질 그래픽 작업용

> [!INFO] 파이프라인이란?
> **파이프라인**은 하나의 거대한 작업을 수행하기까지의 과정을 의미한다.

> [!TIP] 그렇다면.. 렌더 파이프라인이란?
> **렌더 파이프라인**은 3d 객체가 컴퓨터 화면에 그려질 때 까지의 전체 과정을 의미한다.

![[Pasted image 20250224223832.png]]

각 파이프라인은 고유한 특성이 있다.
어떤 파이프 라인을 사용하느냐에 따라 재질(Material), 조명(Light), 텍스쳐(Texture) 등의 셰이더 동작이 달라진다.
즉, 파이프라인 작업 하나로 인해, 객체의 모습과 성능이 완전히 바뀔 수 있다는 뜻이다.

일반적으로 실시간 렌더링 엔진들의 렌더 파이프라인은 다음 4가지 단계를 거친다.
1. **애플리케이션 단계(Application Stage)**
2. **지오메트리 처리 단계(Geometry Procesisng Phase)**
3. **레스터화 단계(Rasterization Stage)**
4. **픽셀 처리 단계(Pixel Processing Stage)**

![[Pasted image 20250224225008.png]]

---
## 08. 애플리케이션 단계
*Application Stage*
**애플리케이션 단계**는 **CPU**에서 시작된다. 여기서는 씬에서 발생하는 대부분의 작업을 처리한다.
- 충돌 감지(Collision Detection)
- 텍스처 애니메이션(Texture Animation)
- 키보드 및 마우스 입력 처리
또한, 메모리에 저장된 데이터를 읽어와 기본 타입(Primitive)로 변환한다.
이 단계가 끝나면, 데이터는 "지오메트리 처리 단계"로 넘어가서, 행렬 연산을 통해 정점의 위치 변환이 일어난다! (Transform 변수가 만들어진다는 뜻이다.)

![[Pasted image 20250224230005.png]]

---
## 09. 지오메트리 처리 단계
*Geometry processing phase*
컴퓨터 화면에 보이는 이미지는 GPU가 CPU의 요청을 받아 만드는 것이다.
GPU가 CPU의 요청을 받아 이미지를 그리는 과정은 크게 두 단계로 나눌 수 있다:
1. 렌더링 상태 설정(Configuration)
2. 화면에 객체 그리기

> [!TIP] 렌더링 상태 설정
> 지오메트리 처리부터 픽셀 처리까지의 계획을 이 때 세운다.

그 중, 지오메트리 처리 단계는 GPU에서 시작되어 객체의 정점을 처리하는 단계이다. 다음 네 가지 과정을 거친다:
1. **정점 셰이딩(Vertex Shading)**: 정점 위치 계산
2. **투영(Projection)**: 3d를 2d로 투사
3. **클리핑(Clipping)**: 씬(시야?) 밖의 객체 제거
4. **화면 매핑(Screen Mapping)**: 2d 스크린 좌표 변환

![[Pasted image 20250224231836.png]]

### 01. 정점 셰이딩
*Vertex Shading*
이전 단계인 애플리케이션 단계에서 만들어진 기본 타입(대부분 삼각형을 사용한다!)을 갖고 정점 셰이딩을 시작한다. 이 과정은 **정점 셰이더 단계(Vertex Shader Stage)** 라고도 부른다.
정점 셰이딩은 이렇게 진행된다:
1. 객체의 정점 위치를 계산한다.
2. 화면에 투사할 수 있도록, 좌표계를 변환한다.
이 때, `Normal`, `Tangent`, `UV Coord` 같은 속성도 다음 단계로 전달할 수 있다!

### 02-03. 투영 및 클리핑
*Projection, Clipping*
이 과정은 카메라 설정이 원근인지, 직교인지에 따라 달라진다.
여기서 렌더링은 카메라의 시야(Frustum) 내에서만 발생한다고 이해하면 된다!
여기서 카메라의 시야를 **뷰 공간(View Space)** 라고 한다.

카메라 시야 밖에 있거나, 걸쳐 있는 객체는 **클리핑**되어 잘려나가고, 렌더링에서 제외된다.

### 04. 화면 매핑
*Screen Mapping*
클리핑 과정을 통과한 객체는 메모리에 저장되고, **화면 매핑**을 통해 3d 좌표가 2d 화면 좌표로 변환된다.
다시 말해, 이 단계를 거쳐 3d 객체가 2d로는 어떻게 보일지 결정된다.

![[Pasted image 20250225231344.png]]

---
## 10. 래스터화 단계
*Rasterization stage*
지오메트리 처리 단계를 거친 객체는 2d 좌표를 가지게 된다.
이제 이 객체가 화면의 어떤 픽셀에 나타날 지를 찾아야 한다. 이 과정을 바로 **래스터화**라 한다.

래스터화 단계는 다음 두 단계로 진행된다:
1. **삼각형 설정(Triangle Setup)**: 삼각형의 경계(Edge)를 정의하는 데이터 구성
2. **삼각형 탐색(Triangle Traversal)**: 경계 안의 픽셀을 찾아낸다.

### 01. 삼각형 설정
*Triangle Setup*
삼각형 경계(윤곽선?, `Edge`)에 대한 방정식을 통해, 데이터를 수집한다.
이 데이터를 바탕으로 어떤 픽셀이 어떤 삼각형과 매핑되는 지를 찾을 수 있다.

### 02. 삼각형 탐색
*Triangle Traversal*
위 삼각형 설정 단계에서 수집한 데이터를 바탕으로, 해당 삼각형 내에 있는 픽셀을 찾아 `Fragments`라는 이름의 그룹으로 묶는다.

여기서 `Fragments`는 색을 입힐 `Pixel`들의 모음이다. 이 `Fragments`는 다음 단계에서 색이나 질감을 입히는 데 사용한다.

![[Pasted image 20250225233857.png]]

---
## 11. 픽셀 처리 단계
*Pixel processing stage*

---
